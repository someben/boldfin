<html>
  <head>
    <script src="http://code.jquery.com/jquery-1.11.1.min.js" type="text/javascript"></script>
    <script src=".quandl-creds.js" type="text/javascript"></script>
    <script language="JavaScript">

// technique from "http://stackoverflow.com/questions/11887934/check-if-daylight-saving-time-is-in-effect-and-if-it-is-for-how-many-hours"
Date.prototype.getStdTimezoneOffset = function() {
  var jan = new Date(this.getFullYear(), 0, 1);
  var jul = new Date(this.getFullYear(), 6, 1);
  return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
}

Date.prototype.isDst = function() {
  return this.getTimezoneOffset() < this.getStdTimezoneOffset();
}

var Dist = {
  eachNum: function(xs, fn) {
    var result = null;
    for (var i=0; i < xs.length; i++) {
      var x = xs[i];
      if (isNaN(x)) {
        continue;
      }
      result = fn(x);
    }
    return result;
  },

  getLength: function(xs) {
    var num = 0;
    this.eachNum(xs, function(x) { num += 1 });
    return num;
  },

  getMean: function(xs) {
    var sum = 0;
    this.eachNum(xs, function(x) { sum += x });
    return sum / this.getLength(xs);
  },

  getSquaredDifferenceSum: function(xs) {
    var mean = this.getMean(xs);
    var sum = 0;
    this.eachNum(xs, function(x) {
      var xSqDiff = x - mean;
      sum += xSqDiff * xSqDiff;
    });
    return sum;
  },

  getVariance: function(xs) {
    return this.getSquaredDifferenceSum(xs) / (this.getLength(xs) - 1);
  },

  getPopulationVariance: function(xs) {
    return this.getSquaredDifferenceSum(xs) / this.getLength(xs);
  },

  getStandardDeviation: function(xs) {
    return Math.sqrt(this.getVariance(xs));
  },

  getPopulationStandardDeviation: function(xs) {
    return Math.sqrt(this.getPopulationVariance(xs));
  }
};

function toConsole() {
  if (window.console) {
    window.console.log.apply(window.console, arguments);
  }
}

function _getQuandlStockPriceTimeSeries(exch, ticker) {
  var url = "http://www.quandl.com/api/v1/datasets/GOOG/" + exch + "_" + ticker;
  if (getQuandlCredentials().authToken) {
    url += "?auth_token=" + getQuandlCredentials().authToken;
  }
  else {
    toConsole("Requesting URL anonymously", url);
  }

  toConsole("About to call out to Quandl API w/ URL:", url);
  var data = null;
  $.ajax({
    url: url,
    async: false,
    success: function(ajaxResult) {
      toConsole("Got data back from Quandl", ajaxResult);
      data = ajaxResult;
    }
  });
  return data;
}

var tmpData = null;
function tmpCallback(data) { tmpData = data; }
function getQuandlStockPriceTimeSeries(exch, ticker) { return tmpData; }

function getStockPriceTimeSeries(exch, ticker) {
  var ts = {};
  var quandlTs = getQuandlStockPriceTimeSeries(exch, ticker);
  for (var j=0; j < quandlTs.data.length; j++) {
    var tsRow = {};
    var tsRowTime = null;
    for (var i=0; i < quandlTs.column_names.length; i++) {
      var featureName = quandlTs.column_names[i].toLowerCase();
      var featureVal = quandlTs.data[j][i];
      if (featureName == "date") {
        var quandlTsRowTimeTz = ((new Date(featureVal).isDst()) ? "-04:00" : "-05:00");
        tsRowTime = new Date(featureVal + "T16:30:00" + quandlTsRowTimeTz) / 1000;
      }
      else {
        tsRow[featureName] = featureVal;
      }
    }
    ts[tsRowTime] = tsRow;
  }
  return ts;
}

function cloneTimeSeriesRow(tsRow, featureNamePrefix) {
  var newTsRow = {}
  for (var featureName in tsRow) {
    var newFeatureName = null;
    if (typeof featureNamePrefix == "undefined") {
      newFeatureName = featureName;
    }
    else {
      newFeatureName = featureNamePrefix + featureName;
    }
    newTsRow[newFeatureName] = tsRow[featureName];
  }
  return newTsRow;
}

function cloneTimeSeries(ts, featureNamePrefix) {
  var newTs = {};
  for (var t in ts) {
    newTs[t] = cloneTimeSeriesRow(ts[t], featureNamePrefix);
  }
  return newTs;
}

function getTimeSeriesTimes(ts) {
  var tsTimes = [];
  for (var t in ts) {
    tsTimes.push(t);
  }
  tsTimes.sort();
  return tsTimes;
}

function getTimeSeriesRowFeatureNames(tsRow) {
  var tsRowFeatureNames = [];
  for (var featureName in tsRow) {
    tsRowFeatureNames.push(featureName);
  }
  tsRowFeatureNames.sort();
  return tsRowFeatureNames;
}

function getTimeSeriesLength(ts) {
  return getTimeSeriesTimes(ts).length;
}

function getTimeSeriesFeatureNames(ts) {
  var featureNames = [];
  for (var t in ts) {
    for (var featureName in ts[t]) {
      if (featureNames.indexOf(featureName) == -1) {
        featureNames.push(featureName);
      }
    }
  }
  featureNames.sort();
  return featureNames;
}

function getTimeSeriesDimensionality(ts) {
  return getTimeSeriesFeatureNames(ts).length;
}

function addDiffFeatures(ts, featureName, diffWin, diffFn) {
  var newTs = cloneTimeSeries(ts);
  var tsRowTimes = getTimeSeriesTimes(ts);
  for (var i = diffWin; i < tsRowTimes.length; i++) {
    var tsRowTime1 = tsRowTimes[i - diffWin];
    var tsRowTime2 = tsRowTimes[i];
    if (ts[tsRowTime1][featureName] && ts[tsRowTime2][featureName]) {
      var diffFeatureVal = diffFn(ts[tsRowTime1][featureName], ts[tsRowTime2][featureName]);
      if (! diffFeatureVal) {
        continue;
      }
      var diffFeatureName = featureName + "(-" + diffWin + " diff)";
      newTs[tsRowTime2][diffFeatureName] = diffFeatureVal;
    }
  }
  return newTs;
};

function addVarFeatures(ts, featureName, varWin, varFn) {
  var newTs = cloneTimeSeries(ts);
  var tsRowTimes = getTimeSeriesTimes(ts);
  for (var i = varWin; i < tsRowTimes.length; i++) {
    var tsRowTime2 = tsRowTimes[i];
    var featureVals = [];
    for (var tIndex = i - varWin; tIndex <= i; tIndex++) {
      var t = tsRowTimes[tIndex];
      featureVals.push(ts[t][featureName]);
    }
    var varFeatureVal = varFn(featureVals);
    if (! varFeatureVal) {
      continue;
    }
    var varFeatureName = featureName + "(-" + varWin + " var)";
    newTs[tsRowTime2][varFeatureName] = varFeatureVal;
  }
  return newTs;
};

function mergeTimeSeries(ts1, ts2) {
  var newTs = cloneTimeSeries(ts1);
  for (var t in ts2) {
    if (! newTs[t]) {
      newTs[t] = {};
    }
    for (var featureName in ts2[t]) {
      newTs[t][featureName] = ts2[t][featureName];
    }
  }
  return newTs;
}

function getSymbolTimeSeries(syms, diffWin, diffFn, varWin, varFn) {
  var ts = null;
  for (var i=0; i < syms.length; i++) {
    var sym = syms[i];
    var symEls = sym.split(":");
    var ticker = symEls[0];
    var exch = symEls[1];

    var symTs = getStockPriceTimeSeries(exch, ticker);
    var featureNames = getTimeSeriesFeatureNames(symTs);
    for (var j=0; j < featureNames.length; j++) {
      var featureName = featureNames[j];
      toConsole("Adding difference features", sym, featureName);
      for (var diffWin1 = 1; diffWin1 <= diffWin; diffWin1++) {
        symTs = addDiffFeatures(symTs, featureName, diffWin1, diffFn);
      }
      toConsole("Adding variance features", sym, featureName);
      for (var varWin1 = 1; varWin1 <= varWin; varWin1++) {
        symTs = addVarFeatures(symTs, featureName, varWin1, varFn);
      }
    }
    symTs = cloneTimeSeries(symTs, sym + ":");
    if (ts) {
      ts = mergeTimeSeries(ts, symTs);
    }
    else {
      ts = symTs;
    }
  }
  return ts;
}

function extractForecastTimeSeries(ts, featureName, forecastWin, diffFn) {
  var newTs = {};
  var tsRowTimes = getTimeSeriesTimes(ts);
  for (var i=0; i < tsRowTimes.length - forecastWin; i++) {
    var tsRowTime1 = tsRowTimes[i];
    var tsRowTime2 = tsRowTimes[i + forecastWin];
    newTs[tsRowTime1] = {};
    if (ts[tsRowTime1][featureName] && ts[tsRowTime2][featureName]) {
      var diffFeatureVal = diffFn(ts[tsRowTime1][featureName], ts[tsRowTime2][featureName]);
      if (! diffFeatureVal) {
        continue;
      }
      var forecastFeatureName = featureName + "(+" + forecastWin + " fwd)";
      newTs[tsRowTime1][forecastFeatureName] = diffFeatureVal;
    }
  }
  return newTs;
};

function selectTimeSeriesRows(ts, fn) {
  var newTs = {};
  var tsRowTimes = getTimeSeriesTimes(ts);
  for (var i=0; i < tsRowTimes.length; i++) {
    var t = tsRowTimes[i];
    if (fn(t, ts[t])) {
      newTs[t] = cloneTimeSeriesRow(ts[t]);
    }
  }
  return newTs;
};

function removeSparseTimeSeriesRows(ts, sparsityFilter) {
  toConsole("Built time series w/ dimensionality & length", getTimeSeriesDimensionality(ts), getTimeSeriesLength(ts));
  var minNumDims = Math.round(getTimeSeriesDimensionality(ts) * sparsityFilter);
  ts = selectTimeSeriesRows(ts, function(t, tsRow) {
    return getTimeSeriesRowFeatureNames(tsRow).length >= minNumDims;
  });
  toConsole("Filtered down to time series w/ dimensionality & length", getTimeSeriesDimensionality(ts), getTimeSeriesLength(ts));
  return ts;
}

$(document).ready(function() {
  var syms = ["NFLX:NASDAQ", "GOOG:NASDAQ"];
  var targetSym = syms[0];

  var diffWin = 3;
  var varWin = 5;
  var forecastWin = 5;  // five trading days
  var sparsityFilter = 0.50;

  var deltaFn = function(x1, x2) {
    return (x2 - x1) / x1;
  };
  var logRetFn = function(x1, x2) {
    return Math.log(x2 / x1);
  };
  var stdevFn = function(xs) {
    return Dist.getStandardDeviation(xs);
  };

  var ts = getSymbolTimeSeries(syms, diffWin, deltaFn, varWin, stdevFn);
  toConsole("Built symbol time series", ts);
  var targetFeatureName = targetSym + ":close";
  var targetTs = extractForecastTimeSeries(ts, targetFeatureName, forecastWin, deltaFn);
  toConsole("Extracted target time series", targetFeatureName, targetTs);
  ts = removeSparseTimeSeriesRows(ts, sparsityFilter);
  // TODO add a feature normalization process
});
    </script>
    <script src="../data/tmp_NASDAQ_NFLX.js" type="text/javascript"></script>
  </head>

  <body>
  </body>
</html>

